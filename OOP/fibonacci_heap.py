from .basic_node import BasicNode
from .heap_node import HeapNode
from .root_node import RootNode
import uuid


class FibonacciHeap:
    def __init__(self, heap_type):
        self._current_root = None
        self._top_node = None
        self._heap_hash = {}

        if heap_type not in ["max", "min"]:
            raise ValueError("Invalid heap type: must be 'max' or 'min'.")
        else:
            self._is_max_heap = heap_type == 'max'

    def add_node(self, priority, unique_id=None, payload: object = None):
        """
        Adds a new, correctly placed, node to the FibonacciHeap with the user-specified values for its attributes.
        :param priority: A numeric value that indicates the priority of this node.
        :param unique_id: A unique ID that will be used to access this node quickly via the heap_hash dictionary.
        :param payload: A custom object that the user may store in the node to add versatility to the structure.
        :return: The unique ID, so that the user may store it to keep track of specific nodes they care about.
        """
        # Handling the priority
        if not isinstance(priority, (int, float)):
            raise TypeError(f"Invalid priority: must be numeric, but received {type(priority)} instead.")

        # Handling the unique_id
        if unique_id is None:
            unique_id = uuid.uuid4()
        elif unique_id in self._heap_hash:
            raise ValueError(f"Invalid unique ID: ID {unique_id} is already in use.")

        # Create the node using the parameters
        adding_node = BasicNode(priority=priority, unique_id=unique_id, payload=payload)

        ### Operations for maintaining the FibonacciHeap ###
        # Add the node to the heap_hash using the unique_id as the key
        self._heap_hash[unique_id] = adding_node

        # Place the new node in the appropriate place within the Fibonacci Heap
        if self._current_root is None:
            self._current_root = RootNode(basic_node=adding_node, left=None, right=None)
        else:
            # Figure out where in the fibonacci heap to put this node.
            # This may involve running a separate method.

        # Return the unique_id so that users may store it to keep track of this node if they want to.
        return unique_id

    def update_priority(self, unique_id, new_priority):
        """
        The FibonacciHeap accesses a specific node using the self.heap_hash value that corresponds to the unique_id key
        and changes its priority to be new_priority.
        :param unique_id: The unique_id of the node to be modified. The value of unique_id was either user specified
        or automatically generated by UUID4 at the time of the node's creation. It is returned by add_node so that
        the user may store it to use this or similar methods later.
        :param new_priority: The new priority value that the node will be updated to have.
        :return:
        """
        return True

    def get_top_node(self):
        """
        Getter method for the _top_node.
        Highest priority if self.is_max_heap is True.
        Lowest priority if self.is_max_heap is False.
        :return: self._top_node
        """
        return self._top_node

    def extract(self):
        """
        Extracts the most important node, removing it and returning its unique_id, priority, and payload.
        Highest priority if self.is_max_heap is True.
        Lowest priority if self.is_max_heap is False.
        :return: A tuple of the extracted node's unique_id, priority, and payload.
        """
        unique_id = self._top_node.get_unique_id()
        priority = self._top_node.get_priority()
        payload = self._top_node.get_payload()

        # <Delete the _top_node>
        # <Restructure the FibonacciHeap>

        return unique_id, priority, payload

    #def batch_extract(self, num):
    #Find a way to extract as a batch in a way that is faster than just doing extract() in a loop
    #Perhaps implement this portion in C or something?
    #    return True

    def export_heap(self, filepath):
        """
        Exports the current state of the Fibonacci heap to a file for storage and use in a new session.
        :return: True if no errors, False if errors.
        """
        return True

    def load_heap(self, filepath):
        """
        Loads and initializes a Fibonacci heap from the file specified by the filepath.
        :return: The FibonacciHeap that was stored in the file specified by the filepath.
        """
        return FibonacciHeap

